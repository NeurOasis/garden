"""
G.A.R.D.E.N. Explorer - A simple Flask application for exploring Neo4j graph data

This application implements the "grasshopper" and "grassroots" patterns for graph exploration:
- "Grassroots": Schema-based entry points (starting from what you know about the data structure)
- "Grasshopper": Node-to-node navigation (exploring connections by hopping between nodes)

The application is designed to be simple, easy to learn, and focused on functionality.
It serves as a practical implementation of concepts from the module generator.

Dependencies:
- Flask
- A middleware module generated by the module generator (imported as 'graph_middleware')

Author: G.A.R.D.E.N. Project Team
Version: 1.0
"""

import os
import csv
import json
import time
import datetime
import functools
from urllib.parse import quote, unquote
from flask import Flask, request, render_template_string, redirect, url_for, session, flash, Response, g

# Import the middleware generated by the module generator
# This middleware provides a Python interface to your Neo4j database
# Note: You'll need to replace 'graph_middleware' with the actual name of your generated module
try:
    import newgraph as gm
except ImportError:
    print("ERROR: Could not import graph middleware. Make sure you've generated it using the module generator.")
    print("Example: python modulegenerator-claude.py -u 'bolt://localhost:7687' -n 'neo4j' -p 'password' -g 'graph_middleware'")
    raise

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------

# Application configuration
# These values can be modified to suit your specific environment
config = {
    # Basic application settings
    'app_name': 'G.A.R.D.E.N. Explorer',
    'app_version': '1.0',
    'debug_mode': True,  # Set to False in production!
    
    # Session settings
    'session_secret_key': os.environ.get('SECRET_KEY', os.urandom(24).hex()),
    'session_lifetime': 60 * 60,  # 1 hour in seconds
    
    # Logging configuration
    'enable_logging': True,
    'log_format': 'text',  # Options: 'text', 'csv', 'json'
    'log_fields': [
        'timestamp',
        'username',
        'ip_address',
        'method',
        'endpoint',
        'node_id',
        'node_label'
    ],
    'log_file': 'garden_activity.log',
    
    # Authentication settings
    'login_attempts_limit': 5,
    'lockout_time': 15 * 60,  # 15 minutes in seconds
    
    # Display settings
    'items_per_page': 20,
    'max_properties_shown': 10,
    'truncate_property_length': 100,
    
    # User accounts - REPLACE THIS WITH A PROPER DATABASE IN PRODUCTION
    # This is just for demonstration and easy setup
    'users': {
        'demo': {
            'password': 'demo123',  # NEVER store plaintext passwords in production!
            'full_name': 'Demo User',
            'department': 'Training',
            'failed_attempts': 0,
            'locked_until': None
        },
        'admin': {
            'password': 'admin123',  # NEVER store plaintext passwords in production!
            'full_name': 'Administrator',
            'department': 'IT',
            'failed_attempts': 0,
            'locked_until': None
        }
    }
}

# -----------------------------------------------------------------------------
# Flask Application Setup
# -----------------------------------------------------------------------------

app = Flask(__name__)
app.secret_key = config['session_secret_key']
app.config['PERMANENT_SESSION_LIFETIME'] = config['session_lifetime']
app.config['TEMPLATES_AUTO_RELOAD'] = config['debug_mode']

# -----------------------------------------------------------------------------
# Logging Functionality
# -----------------------------------------------------------------------------

def log_activity(activity_type, node_id=None, node_label=None, additional_data=None):
    """
    Log user activity to a file based on configured format.
    
    This function writes log entries according to the format specified in the config:
    - text: Simple line-based log with pipe separators
    - csv: CSV formatted log (easier to import into spreadsheets)
    - json: JSON formatted log (easier to parse programmatically)
    
    Args:
        activity_type (str): The type of activity (e.g., 'view_node', 'list_nodes')
        node_id (str, optional): The ID of the node being accessed
        node_label (str, optional): The label of the node being accessed
        additional_data (dict, optional): Any additional data to log
    
    Returns:
        bool: True if logging succeeded, False otherwise
    """
    if not config['enable_logging']:
        return True
    
    # Prepare log data dictionary with all possible fields
    log_data = {
        'timestamp': datetime.datetime.now().isoformat(),
        'username': session.get('username', 'anonymous'),
        'ip_address': request.remote_addr,
        'method': request.method,
        'endpoint': request.path,
        'activity_type': activity_type,
        'node_id': node_id or '',
        'node_label': node_label or '',
        'user_agent': request.user_agent.string,
        'referer': request.referrer or ''
    }
    
    # Add any additional data
    if additional_data:
        log_data.update(additional_data)
    
    # Filter to only include configured fields
    filtered_data = {k: v for k, v in log_data.items() if k in config['log_fields']}
    
    try:
        log_format = config['log_format'].lower()
        
        with open(config['log_file'], 'a', encoding='utf-8') as f:
            if log_format == 'json':
                # JSON format (one object per line)
                f.write(json.dumps(filtered_data) + '\n')
                
            elif log_format == 'csv':
                # CSV format
                writer = csv.DictWriter(f, fieldnames=config['log_fields'])
                # Write header if file is empty
                if f.tell() == 0:
                    writer.writeheader()
                writer.writerow(filtered_data)
                
            else:
                # Default text format
                values = [str(filtered_data.get(field, '')) for field in config['log_fields']]
                f.write('|'.join(values) + '\n')
                
        return True
    except Exception as e:
        # In a production environment, you might want to log this error elsewhere
        print(f"Logging error: {e}")
        return False

# -----------------------------------------------------------------------------
# Authentication & Authorization
# -----------------------------------------------------------------------------

def login_required(f):
    """
    Decorator to require login for specific routes.
    
    This decorator checks if the user is logged in before allowing access to a route.
    If not logged in, the user is redirected to the login page.
    
    Args:
        f (function): The route function to decorate
        
    Returns:
        function: The decorated function
    """
    @functools.wraps(f)
    def decorated_function(*args, **kwargs):
        if 'username' not in session:
            # Log the unauthorized access attempt
            log_activity('unauthorized_access')
            # Store the original URL for redirect after login
            session['next_url'] = request.url
            flash('Please log in to access this page.', 'warning')
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['GET', 'POST'])
def login():
    """
    Handle user login.
    
    GET: Display the login form
    POST: Process the login form submission
    
    Returns:
        Response: Rendered login page or redirect to destination
    """
    error = None
    
    if request.method == 'POST':
        username = request.form.get('username', '')
        password = request.form.get('password', '')
        
        # Check if user exists
        if username in config['users']:
            user = config['users'][username]
            
            # Check if account is locked
            if user['locked_until'] and user['locked_until'] > time.time():
                remaining_time = int((user['locked_until'] - time.time()) / 60)
                error = f"This account is temporarily locked. Please try again in {remaining_time} minutes."
                log_activity('login_failed', additional_data={'reason': 'account_locked'})
            
            # Verify password (in production, use proper password hashing!)
            elif user['password'] == password:
                # Reset failed attempts on successful login
                user['failed_attempts'] = 0
                user['locked_until'] = None
                
                # Create session
                session['username'] = username
                session['full_name'] = user['full_name']
                session['department'] = user['department']
                session.permanent = True
                
                # Log successful login
                log_activity('login_successful')
                
                # Redirect to the original URL or dashboard
                next_url = session.pop('next_url', url_for('index'))
                return redirect(next_url)
            else:
                # Increment failed attempts
                user['failed_attempts'] += 1
                
                # Lock account if too many failed attempts
                if user['failed_attempts'] >= config['login_attempts_limit']:
                    user['locked_until'] = time.time() + config['lockout_time']
                    error = f"Too many failed login attempts. Account locked for {config['lockout_time'] // 60} minutes."
                    log_activity('account_locked')
                else:
                    error = "Invalid username or password."
                    log_activity('login_failed', additional_data={'reason': 'invalid_credentials'})
        else:
            # User doesn't exist, but don't reveal this information
            error = "Invalid username or password."
            log_activity('login_failed', additional_data={'reason': 'user_not_found'})
    
    # Render the login template
    return render_template_string("""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Login - {{ config.app_name }}</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; }
                .container { max-width: 400px; margin: 40px auto; padding: 20px; background-color: white; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
                .form-group { margin-bottom: 15px; }
                label { display: block; margin-bottom: 5px; font-weight: bold; }
                input[type="text"], input[type="password"] { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ddd; border-radius: 4px; }
                button { background-color: #4CAF50; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; }
                .error { color: #f44336; margin-bottom: 15px; }
                .flash { padding: 10px; margin-bottom: 15px; border-radius: 4px; }
                .flash.error, .flash.danger { background-color: #FFEBEE; color: #B71C1C; }
                .flash.success { background-color: #E8F5E9; color: #1B5E20; }
                .flash.warning { background-color: #FFF8E1; color: #F57F17; }
                .flash.info { background-color: #E3F2FD; color: #0D47A1; }
                .header { text-align: center; margin-bottom: 20px; }
                .app-title { font-size: 24px; margin-bottom: 5px; color: #2E7D32; }
                .app-subtitle { font-size: 14px; color: #555; }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <div class="app-title">{{ config.app_name }}</div>
                    <div class="app-subtitle">Explore your data with ease</div>
                </div>
                
                {% if error %}
                <div class="error">{{ error }}</div>
                {% endif %}
                
                {% with messages = get_flashed_messages(with_categories=true) %}
                  {% if messages %}
                    {% for category, message in messages %}
                      <div class="flash {{ category }}">{{ message }}</div>
                    {% endfor %}
                  {% endif %}
                {% endwith %}
                
                <form method="post">
                    <div class="form-group">
                        <label for="username">Username:</label>
                        <input type="text" id="username" name="username" required autofocus>
                    </div>
                    <div class="form-group">
                        <label for="password">Password:</label>
                        <input type="password" id="password" name="password" required>
                    </div>
                    <button type="submit">Login</button>
                </form>
                
                <p style="margin-top: 20px; font-size: 12px; color: #777; text-align: center;">
                    Demo credentials: username "demo", password "demo123"
                </p>
            </div>
        </body>
        </html>
    """, error=error, config=config)

@app.route('/logout')
def logout():
    """
    Handle user logout.
    
    Removes the user from the session and redirects to the login page.
    
    Returns:
        Response: Redirect to login page
    """
    # Log the logout
    if 'username' in session:
        log_activity('logout')
    
    # Clear the session
    session.clear()
    
    flash('You have been logged out.', 'info')
    return redirect(url_for('login'))

# -----------------------------------------------------------------------------
# Helper Functions
# -----------------------------------------------------------------------------

def get_node_by_id(node_id, label=None):
    """
    Retrieve a node by its ID, optionally with a specific label.
    
    This function demonstrates how to use the middleware to fetch node data.
    It handles the different ways nodes might be identified based on the database schema.
    
    Args:
        node_id (str): The ID of the node to retrieve
        label (str, optional): The label of the node, if known
    
    Returns:
        dict: The node data if found, None otherwise
    """
    try:
        # If we know the label, we can use the specific node retrieval function
        if label:
            # Convert label to function name (lowercase, replace special chars)
            func_name = label.lower().replace(':', '_').replace('-', '_')
            
            # Get the corresponding function from the nodes interface
            node_func = getattr(gm.nodes, func_name, None)
            
            if node_func:
                # Call the function with the UUID parameter
                results = node_func(uuid=node_id)
                return results[0] if results else None
        
        # If we don't know the label or the specific function doesn't exist,
        # we need to try a more generic approach
        
        # Option 1: If the middleware provides a generic find_node function
        if hasattr(gm, 'find_node'):
            return gm.find_node(node_id)
        
        # Option 2: Try each node type until we find a match
        for label_name in gm.METADATA['node_labels']:
            func_name = label_name.lower().replace(':', '_').replace('-', '_')
            node_func = getattr(gm.nodes, func_name, None)
            
            if node_func:
                results = node_func(uuid=node_id)
                if results:
                    return results[0]
        
        # Node not found with any available method
        return None
    
    except Exception as e:
        print(f"Error retrieving node: {e}")
        return None

def format_property_value(value, max_length=100):
    """
    Format a property value for display, truncating if necessary.
    
    Args:
        value: The property value to format
        max_length (int): Maximum length before truncation
    
    Returns:
        str: The formatted value
    """
    if value is None:
        return "<empty>"
    
    # Convert to string
    str_value = str(value)
    
    # Truncate if too long
    if len(str_value) > max_length:
        return str_value[:max_length] + "..."
    
    return str_value

def get_relationship_label(rel_type, start_label, end_label):
    """
    Generate a human-readable label for a relationship.
    
    Args:
        rel_type (str): The relationship type
        start_label (str): The label of the start node
        end_label (str): The label of the end node
    
    Returns:
        str: A human-readable relationship description
    """
    # Convert relationship type to a readable format
    readable_type = rel_type.replace('_', ' ').title()
    
    return f"{start_label} {readable_type} {end_label}"

def get_label_count(label):
    """Safe function to count nodes with a specific label."""
    try:
        # Convert label to function name
        func_name = label.lower().replace(':', '_').replace('-', '_')
        # Get the corresponding function
        func = getattr(gm.nodes, func_name, None)
        if func is None:
            return "0"
        # Execute a count query instead of fetching all nodes
        query = f"MATCH (n:{label}) RETURN count(n) AS count"
        result = gm.execute_query(query)
        return str(result[0]['count']) if result else "0"
    except Exception as e:
        print(f"Error counting {label} nodes: {e}")
        return "?"

# -----------------------------------------------------------------------------
# Routes: Core Application
# -----------------------------------------------------------------------------

@app.route('/')
@login_required
def index():
    """
    Home page / dashboard of the application.
    
    Displays links to the grassroots entry points.
    
    Returns:
        Response: Rendered home page
    """
    # Log the dashboard access
    log_activity('view_dashboard')
    
    # Get node labels from the middleware metadata
    node_labels = gm.METADATA.get('node_labels', [])
    relationship_types = gm.METADATA.get('edge_types', [])
    
    # Render the template
    return render_template_string("""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Dashboard - {{ config.app_name }}</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; }
                .container { max-width: 1000px; margin: 0 auto; padding: 20px; background-color: white; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
                h1, h2, h3 { color: #2E7D32; }
                .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #ddd; padding-bottom: 10px; }
                .user-info { text-align: right; }
                .section { margin-bottom: 30px; }
                .card { background-color: #f9f9f9; border-radius: 5px; padding: 15px; margin-bottom: 15px; }
                .card h3 { margin-top: 0; }
                .card p { margin-bottom: 10px; }
                .button { display: inline-block; padding: 8px 15px; background-color: #4CAF50; color: white; text-decoration: none; border-radius: 4px; }
                .button:hover { background-color: #45a049; }
                ul { list-style-type: none; padding: 0; }
                li { margin-bottom: 10px; }
                a { color: #2E7D32; text-decoration: none; }
                a:hover { text-decoration: underline; }
                .label-count { color: #777; font-size: 0.9em; }
                .footer { margin-top: 30px; text-align: center; font-size: 0.8em; color: #777; border-top: 1px solid #ddd; padding-top: 10px; }
                .flash { padding: 10px; margin-bottom: 15px; border-radius: 4px; }
                .flash.error, .flash.danger { background-color: #FFEBEE; color: #B71C1C; }
                .flash.success { background-color: #E8F5E9; color: #1B5E20; }
                .flash.warning { background-color: #FFF8E1; color: #F57F17; }
                .flash.info { background-color: #E3F2FD; color: #0D47A1; }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>{{ config.app_name }}</h1>
                    <div class="user-info">
                        <p>
                            Welcome, <strong>{{ session.full_name }}</strong><br>
                            Department: {{ session.department }}<br>
                            <a href="{{ url_for('logout') }}">Logout</a>
                        </p>
                    </div>
                </div>
                
                {% with messages = get_flashed_messages(with_categories=true) %}
                  {% if messages %}
                    {% for category, message in messages %}
                      <div class="flash {{ category }}">{{ message }}</div>
                    {% endfor %}
                  {% endif %}
                {% endwith %}
                
                <div class="section">
                    <h2>Grassroots: Schema-Based Entry Points</h2>
                    <p>Start exploring from what you know about the data structure.</p>
                    
                    <div class="card">
                        <h3>Node Types (Labels)</h3>
                        <p>Select a node type to view all instances:</p>
                        <ul>
                            {% for label in node_labels %}
                            <li>
                                <a href="{{ url_for('list_nodes', label=label) }}">{{ label }}</a>
                                <span class="label-count">{{ get_label_count(label) }}</span>
                            </li>
                            {% endfor %}
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h3>Relationship Types</h3>
                        <p>Select a relationship type to view all instances:</p>
                        <ul>
                            {% for rel_type in relationship_types %}
                            <li>
                                <a href="{{ url_for('list_relationships', type=rel_type) }}">{{ rel_type }}</a>
                            </li>
                            {% endfor %}
                        </ul>
                    </div>
                </div>
                
                <div class="section">
                    <h2>Search by ID</h2>
                    <p>If you know the unique identifier of a node, you can access it directly:</p>
                    <form action="{{ url_for('view_node_by_id') }}" method="get">
                        <input type="text" name="node_id" placeholder="Enter node UUID" required>
                        <button type="submit">View Node</button>
                    </form>
                </div>
                
                <div class="footer">
                    {{ config.app_name }} v{{ config.app_version }} | Data accessed through module generator middleware
                </div>
            </div>
        </body>
        </html>
    """, config=config, node_labels=node_labels, relationship_types=relationship_types, 
    get_label_count=lambda label: get_label_count)

@app.route('/nodes/<label>')
@login_required
def list_nodes(label):
    """
    List all nodes with a specific label (grassroots entry point).
    
    Args:
        label (str): The label of the nodes to list
    
    Returns:
        Response: Rendered list of nodes
    """
    # Log the node list access
    log_activity('list_nodes', node_label=label)
    
    # Convert label to function name (lowercase, replace special chars)
    func_name = label.lower().replace(':', '_').replace('-', '_')
    
    try:
        # Get the corresponding function from the nodes interface
        node_func = getattr(gm.nodes, func_name)
        
        # Call the function to get all nodes with this label
        nodes = node_func()
        
        # Get the properties for this node type from metadata
        node_properties = gm.METADATA.get('node_properties', {}).get(label, {})
        
        # Determine which properties to display
        if node_properties:
            # Use the first few properties from metadata
            display_properties = list(node_properties.keys())[:config['max_properties_shown']]
        else:
            # If no metadata, try to extract common properties from the first few nodes
            all_props = set()
            for node in nodes[:10]:
                all_props.update(node['props'].keys())
            display_properties = sorted(all_props)[:config['max_properties_shown']]
        
        # Render the template
        return render_template_string("""
            <!DOCTYPE html>
            <html>
            <head>
                <title>{{ label }} Nodes - {{ config.app_name }}</title>
                <style>
                    body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; }
                    .container { max-width: 1200px; margin: 0 auto; padding: 20px; background-color: white; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
                    h1, h2 { color: #2E7D32; }
                    .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
                    .navigation { margin-bottom: 20px; }
                    .navigation a { margin-right: 10px; }
                    table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
                    th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
                    th { background-color: #f2f2f2; }
                    tr:hover { background-color: #f9f9f9; }
                    .node-link { color: #2E7D32; text-decoration: none; }
                    .node-link:hover { text-decoration: underline; }
                    .pagination { margin-top: 20px; }
                    .pagination a { margin-right: 5px; padding: 5px 10px; border: 1px solid #ddd; text-decoration: none; }
                    .pagination a.active { background-color: #4CAF50; color: white; border-color: #4CAF50; }
                    .footer { margin-top: 30px; text-align: center; font-size: 0.8em; color: #777; border-top: 1px solid #ddd; padding-top: 10px; }
                </style>
            </head>
            <body>
                <div class="container">
                    <div class="header">
                        <h1>{{ label }} Nodes</h1>
                    </div>
                    
                    <div class="navigation">
                        <a href="{{ url_for('index') }}">&larr; Back to Dashboard</a>
                    </div>
                    
                    <p>Found {{ nodes|length }} nodes with label "{{ label }}"</p>
                    
                    {% if nodes %}
                    <table>
                        <thead>
                            <tr>
                                <th>ID</th>
                                {% for prop in display_properties %}
                                <th>{{ prop }}</th>
                                {% endfor %}
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for node in nodes %}
                            <tr>
                                <td>{{ node.uuid|truncate(8, true, '') }}...</td>
                                {% for prop in display_properties %}
                                <td>{{ format_value(node.props.get(prop)) }}</td>
                                {% endfor %}
                                <td>
                                    <a href="{{ url_for('view_node', node_id=node.uuid, label=label) }}" class="node-link">View</a>
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                    {% else %}
                    <p>No nodes found with this label.</p>
                    {% endif %}
                    
                    <div class="footer">
                        {{ config.app_name }} v{{ config.app_version }} | Data accessed through module generator middleware
                    </div>
                </div>
            </body>
            </html>
        """, config=config, label=label, nodes=nodes, display_properties=display_properties, 
        format_value=lambda v: format_property_value(v, config['truncate_property_length']))
    
    except (AttributeError, Exception) as e:
        flash(f"Error listing nodes: {str(e)}", "error")
        return redirect(url_for('index'))

@app.route('/relationships/<type>')
@login_required
def list_relationships(type):
    """
    List all relationships of a specific type (grassroots entry point).
    
    Args:
        type (str): The type of relationships to list
    
    Returns:
        Response: Rendered list of relationships
    """
    # Log the relationship list access
    log_activity('list_relationships', additional_data={'relationship_type': type})
    
    # Convert type to function name (lowercase, replace special chars)
    func_name = type.lower().replace(':', '_').replace('-', '_')
    
    try:
        # Get the corresponding function from the edges interface
        edge_func = getattr(gm.edges, func_name)
        
        # Call the function to get all relationships with this type
        relationships = edge_func()
        
        # Limit the number of relationships shown
        relationships = relationships[:config['items_per_page']]
        
        # Get the properties for this relationship type from metadata
        rel_properties = gm.METADATA.get('edge_properties', {}).get(type, {})
        
        # Determine which properties to display
        if rel_properties:
            # Use the first few properties from metadata
            display_properties = list(rel_properties.keys())[:config['max_properties_shown']]
        else:
            # If no metadata, try to extract common properties from the first few relationships
            all_props = set()
            for _, rel, _ in relationships[:10]:
                all_props.update(rel['props'].keys())
            display_properties = sorted(all_props)[:config['max_properties_shown']]
        
        # Render the template
        return render_template_string("""
            <!DOCTYPE html>
            <html>
            <head>
                <title>{{ type }} Relationships - {{ config.app_name }}</title>
                <style>
                    body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; }
                    .container { max-width: 1200px; margin: 0 auto; padding: 20px; background-color: white; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
                    h1, h2 { color: #2E7D32; }
                    .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
                    .navigation { margin-bottom: 20px; }
                    .navigation a { margin-right: 10px; }
                    table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
                    th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
                    th { background-color: #f2f2f2; }
                    tr:hover { background-color: #f9f9f9; }
                    .node-link { color: #2E7D32; text-decoration: none; }
                    .node-link:hover { text-decoration: underline; }
                    .footer { margin-top: 30px; text-align: center; font-size: 0.8em; color: #777; border-top: 1px solid #ddd; padding-top: 10px; }
                </style>
            </head>
            <body>
                <div class="container">
                    <div class="header">
                        <h1>{{ type }} Relationships</h1>
                    </div>
                    
                    <div class="navigation">
                        <a href="{{ url_for('index') }}">&larr; Back to Dashboard</a>
                    </div>
                    
                    <p>Showing up to {{ config.items_per_page }} relationships with type "{{ type }}"</p>
                    
                    {% if relationships %}
                    <table>
                        <thead>
                            <tr>
                                <th>From</th>
                                <th>To</th>
                                {% for prop in display_properties %}
                                <th>{{ prop }}</th>
                                {% endfor %}
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for source, rel, target in relationships %}
                            <tr>
                                <td>
                                    <a href="{{ url_for('view_node', node_id=source.uuid, label=source.labels[0] if source.labels else None) }}" class="node-link">
                                        {{ get_node_label(source) }}
                                    </a>
                                </td>
                                <td>
                                    <a href="{{ url_for('view_node', node_id=target.uuid, label=target.labels[0] if target.labels else None) }}" class="node-link">
                                        {{ get_node_label(target) }}
                                    </a>
                                </td>
                                {% for prop in display_properties %}
                                <td>{{ format_value(rel.props.get(prop)) }}</td>
                                {% endfor %}
                                <td>
                                    <a href="{{ url_for('view_relationship', rel_id=rel.uuid, type=type) }}" class="node-link">View</a>
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                    {% else %}
                    <p>No relationships found with this type.</p>
                    {% endif %}
                    
                    <div class="footer">
                        {{ config.app_name }} v{{ config.app_version }} | Data accessed through module generator middleware
                    </div>
                </div>
            </body>
            </html>
        """, config=config, type=type, relationships=relationships, display_properties=display_properties, 
        format_value=lambda v: format_property_value(v, config['truncate_property_length']),
        get_node_label=lambda node: node['props'].get('name', node['props'].get('title', node['uuid'][:8] + '...')))
    
    except (AttributeError, Exception) as e:
        flash(f"Error listing relationships: {str(e)}", "error")
        return redirect(url_for('index'))

@app.route('/node/id')
@login_required
def view_node_by_id():
    """
    View a node by its ID (direct access).
    
    This route handles the search form from the dashboard.
    
    Returns:
        Response: Redirect to the node view or back to dashboard
    """
    node_id = request.args.get('node_id')
    
    if not node_id:
        flash("Please provide a node ID.", "warning")
        return redirect(url_for('index'))
    
    # Try to find the node without knowing its label
    node = get_node_by_id(node_id)
    
    if node:
        # If found, redirect to the view_node route with the appropriate parameters
        label = node['labels'][0] if node['labels'] else None
        return redirect(url_for('view_node', node_id=node_id, label=label))
    else:
        flash(f"No node found with ID: {node_id}", "error")
        return redirect(url_for('index'))

@app.route('/node/<node_id>')
@login_required
def view_node(node_id, label=None):
    """
    View a single node and its connections (grasshopper pattern).
    
    Args:
        node_id (str): The ID of the node to view
        label (str, optional): The label of the node, if known
    
    Returns:
        Response: Rendered node view
    """
    # Get the label from the query parameter if not provided in the route
    if not label:
        label = request.args.get('label')
    
    # Log the node view
    log_activity('view_node', node_id=node_id, node_label=label)
    
    # Get the node data
    node = get_node_by_id(node_id, label)
    
    if not node:
        flash(f"Node not found: {node_id}", "error")
        return redirect(url_for('index'))
    
    # Use the first label from the node if we didn't have one
    if not label and node['labels']:
        label = node['labels'][0]
    
    # Get incoming and outgoing relationships
    incoming_relationships = []
    outgoing_relationships = []
    
    # This would be more efficient with a single query in a real implementation
    # but we're demonstrating the middleware approach here
    try:
        # For each relationship type in the metadata
        for rel_type in gm.METADATA.get('edge_types', []):
            # Convert type to function name
            func_name = rel_type.lower().replace(':', '_').replace('-', '_')
            edge_func = getattr(gm.edges, func_name)
            
            # Check for outgoing relationships
            for source, rel, target in edge_func(start_node_uuid=node_id):
                outgoing_relationships.append({
                    'source': source,
                    'relationship': rel,
                    'target': target,
                    'type': rel_type
                })
            
            # Check for incoming relationships
            for source, rel, target in edge_func(end_node_uuid=node_id):
                incoming_relationships.append({
                    'source': source,
                    'relationship': rel,
                    'target': target,
                    'type': rel_type
                })
    except Exception as e:
        # Log the error but continue with what we have
        print(f"Error fetching relationships: {e}")
    
    # Render the template
    return render_template_string("""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Node: {{ get_node_title(node) }} - {{ config.app_name }}</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; }
                .container { max-width: 1200px; margin: 0 auto; padding: 20px; background-color: white; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
                h1, h2, h3 { color: #2E7D32; }
                .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
                .navigation { margin-bottom: 20px; }
                .navigation a { margin-right: 10px; }
                .card { background-color: #f9f9f9; border-radius: 5px; padding: 15px; margin-bottom: 20px; }
                .property-table { width: 100%; border-collapse: collapse; }
                .property-table th, .property-table td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
                .property-table th { width: 30%; background-color: #f2f2f2; }
                .relationship-section { margin-top: 30px; }
                .relationship-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
                .relationship-table th, .relationship-table td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
                .relationship-table th { background-color: #f2f2f2; }
                .node-link { color: #2E7D32; text-decoration: none; }
                .node-link:hover { text-decoration: underline; }
                .badge { display: inline-block; padding: 3px 7px; border-radius: 3px; background-color: #e0e0e0; font-size: 0.8em; margin-right: 5px; }
                .footer { margin-top: 30px; text-align: center; font-size: 0.8em; color: #777; border-top: 1px solid #ddd; padding-top: 10px; }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>Node: {{ get_node_title(node) }}</h1>
                </div>
                
                <div class="navigation">
                    <a href="{{ url_for('index') }}">&larr; Back to Dashboard</a>
                    {% if label %}
                    <a href="{{ url_for('list_nodes', label=label) }}">&larr; Back to {{ label }} Nodes</a>
                    {% endif %}
                </div>
                
                <div class="card">
                    <h2>Node Details</h2>
                    <p>
                        <strong>ID:</strong> {{ node.uuid }}<br>
                        <strong>Labels:</strong> 
                        {% for label in node.labels %}
                        <span class="badge">{{ label }}</span>
                        {% endfor %}
                    </p>
                    
                    <h3>Properties</h3>
                    <table class="property-table">
                        <tbody>
                            {% for key, value in node.props.items() %}
                            <tr>
                                <th>{{ key }}</th>
                                <td>{{ format_value(value) }}</td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
                
                <div class="relationship-section">
                    <h2>Outgoing Relationships ({{ outgoing_relationships|length }})</h2>
                    {% if outgoing_relationships %}
                    <table class="relationship-table">
                        <thead>
                            <tr>
                                <th>Relationship Type</th>
                                <th>Target Node</th>
                                <th>Properties</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for item in outgoing_relationships %}
                            <tr>
                                <td>{{ item.type }}</td>
                                <td>
                                    <a href="{{ url_for('view_node', node_id=item.target.uuid, label=item.target.labels[0] if item.target.labels else None) }}" class="node-link">
                                        {{ get_node_title(item.target) }}
                                    </a>
                                </td>
                                <td>
                                    {% for key, value in item.relationship.props.items() %}
                                    <strong>{{ key }}:</strong> {{ format_value(value) }}<br>
                                    {% endfor %}
                                </td>
                                <td>
                                    <a href="{{ url_for('view_relationship', rel_id=item.relationship.uuid, type=item.type) }}" class="node-link">View Relationship</a>
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                    {% else %}
                    <p>No outgoing relationships found.</p>
                    {% endif %}
                </div>
                
                <div class="relationship-section">
                    <h2>Incoming Relationships ({{ incoming_relationships|length }})</h2>
                    {% if incoming_relationships %}
                    <table class="relationship-table">
                        <thead>
                            <tr>
                                <th>Relationship Type</th>
                                <th>Source Node</th>
                                <th>Properties</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for item in incoming_relationships %}
                            <tr>
                                <td>{{ item.type }}</td>
                                <td>
                                    <a href="{{ url_for('view_node', node_id=item.source.uuid, label=item.source.labels[0] if item.source.labels else None) }}" class="node-link">
                                        {{ get_node_title(item.source) }}
                                    </a>
                                </td>
                                <td>
                                    {% for key, value in item.relationship.props.items() %}
                                    <strong>{{ key }}:</strong> {{ format_value(value) }}<br>
                                    {% endfor %}
                                </td>
                                <td>
                                    <a href="{{ url_for('view_relationship', rel_id=item.relationship.uuid, type=item.type) }}" class="node-link">View Relationship</a>
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                    {% else %}
                    <p>No incoming relationships found.</p>
                    {% endif %}
                </div>
                
                <div class="footer">
                    {{ config.app_name }} v{{ config.app_version }} | Data accessed through module generator middleware
                </div>
            </div>
        </body>
        </html>
    """, config=config, node=node, label=label, 
    outgoing_relationships=outgoing_relationships, 
    incoming_relationships=incoming_relationships,
    format_value=lambda v: format_property_value(v, config['truncate_property_length']),
    get_node_title=lambda node: node['props'].get('name', node['props'].get('title', node['uuid'])))

@app.route('/relationship/<rel_id>')
@login_required
def view_relationship(rel_id):
    """
    View a single relationship with its source and target nodes.
    
    Args:
        rel_id (str): The ID of the relationship to view
    
    Returns:
        Response: Rendered relationship view
    """
    rel_type = request.args.get('type')
    
    # Log the relationship view
    log_activity('view_relationship', additional_data={'relationship_id': rel_id, 'relationship_type': rel_type})
    
    # The actual implementation would retrieve the relationship by ID
    # Since the middleware might not have a direct function for this,
    # we would implement a search across relationship types
    
    # For simplicity, we'll redirect to the dashboard with an error message
    flash("Relationship view is not fully implemented in this example.", "info")
    return redirect(url_for('index'))

# -----------------------------------------------------------------------------
# Error Handlers
# -----------------------------------------------------------------------------

@app.errorhandler(404)
def page_not_found(e):
    """
    Handle 404 Not Found errors.
    
    Args:
        e: The error
    
    Returns:
        Response: Error page
    """
    return render_template_string("""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Page Not Found - {{ config.app_name }}</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; }
                .container { max-width: 600px; margin: 40px auto; padding: 20px; background-color: white; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center; }
                h1 { color: #2E7D32; }
                .error-code { font-size: 72px; margin: 0; color: #ccc; }
                .button { display: inline-block; margin-top: 20px; padding: 10px 20px; background-color: #4CAF50; color: white; text-decoration: none; border-radius: 4px; }
                .button:hover { background-color: #45a049; }
            </style>
        </head>
        <body>
            <div class="container">
                <p class="error-code">404</p>
                <h1>Page Not Found</h1>
                <p>The page you're looking for doesn't exist or was moved.</p>
                <a href="{{ url_for('index') }}" class="button">Return to Dashboard</a>
            </div>
        </body>
        </html>
    """, config=config), 404

@app.errorhandler(500)
def server_error(e):
    """
    Handle 500 Internal Server Error.
    
    Args:
        e: The error
    
    Returns:
        Response: Error page
    """
    # Log the error
    log_activity('server_error', additional_data={'error': str(e)})
    
    return render_template_string("""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Server Error - {{ config.app_name }}</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; }
                .container { max-width: 600px; margin: 40px auto; padding: 20px; background-color: white; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center; }
                h1 { color: #2E7D32; }
                .error-code { font-size: 72px; margin: 0; color: #ccc; }
                .button { display: inline-block; margin-top: 20px; padding: 10px 20px; background-color: #4CAF50; color: white; text-decoration: none; border-radius: 4px; }
                .button:hover { background-color: #45a049; }
            </style>
        </head>
        <body>
            <div class="container">
                <p class="error-code">500</p>
                <h1>Server Error</h1>
                <p>Something went wrong on our end. Please try again later.</p>
                <a href="{{ url_for('index') }}" class="button">Return to Dashboard</a>
            </div>
        </body>
        </html>
    """, config=config), 500

# -----------------------------------------------------------------------------
# Application Entry Point
# -----------------------------------------------------------------------------

@app.before_request
def before_request():
    """
    Execute code before each request is processed.
    
    This function sets up request-specific variables and performs logging.
    """
    # Start timer for request duration
    g.start_time = time.time()
    
    # Add trailing slash for ping tracking, but only for non-static resources
    if config['enable_logging'] and not request.path.startswith('/static/'):
        # Check if this is a browser ping for tracking
        if request.args.get('ping') == '1':
            log_activity('link_click', additional_data={'referrer': request.referrer})

@app.after_request
def after_request(response):
    """
    Execute code after each request is processed.
    
    This function finalizes request processing and can modify the response.
    
    Args:
        response: The response object
        
    Returns:
        Response: The modified response
    """
    # Calculate request duration
    if hasattr(g, 'start_time'):
        duration = time.time() - g.start_time
        # Add timing header for debugging
        if config['debug_mode']:
            response.headers['X-Request-Duration'] = str(duration)
    
    return response

@app.template_filter('urlencode')
def urlencode_filter(s):
    """
    Template filter to URL-encode a string.
    
    Args:
        s: The string to encode
        
    Returns:
        str: The URL-encoded string
    """
    if isinstance(s, str):
        s = s.encode('utf-8')
    return quote(s)

@app.template_filter('truncate')
def truncate_filter(s, length=50, end='...'):
    """
    Template filter to truncate a string.
    
    Args:
        s: The string to truncate
        length (int): Maximum length
        end (str): String to append if truncated
        
    Returns:
        str: The truncated string
    """
    if not s:
        return ''
    
    s = str(s)
    if len(s) <= length:
        return s
    else:
        return s[:length] + end

# Start the application when run directly
if __name__ == '__main__':
    # Create log file if logging is enabled and file doesn't exist
    if config['enable_logging'] and not os.path.exists(config['log_file']):
        log_format = config['log_format'].lower()
        
        with open(config['log_file'], 'w', encoding='utf-8') as f:
            if log_format == 'csv':
                # Write CSV header
                writer = csv.DictWriter(f, fieldnames=config['log_fields'])
                writer.writeheader()
            elif log_format == 'json':
                # For JSON, we don't need a header
                pass
            else:
                # For text format, write a header comment
                f.write('# ' + '|'.join(config['log_fields']) + '\n')
    
    print(f"Starting {config['app_name']} v{config['app_version']}...")
    print(f"Debug mode: {'Enabled' if config['debug_mode'] else 'Disabled'}")
    print(f"Open your browser and navigate to http://localhost:5000")
    
    app.run(debug=config['debug_mode'])
